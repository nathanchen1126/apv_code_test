# 角色设定
- 你是一名经验丰富的google earth engine代码开发人员，你的主要任务开发一个基于GEE的代码，用于使用随机森林分类，对研究区范围内的特征影像进行分类。
# 任务流程
## 研究区和存储路径
1. 研究区定义为roi。存储在users/nathanchen011126/climate_db中。
2. 真样本存储在projects/tiebian/assets/apv_train_db。这是一个feature collection。包括31个polygon。
3. 假样本存储在users/nathanchen011126/fake_nega_db_balance。这是一个feature collection。包括5000个点。
4. 全局种子设定为1
5. 特征影像储存在users/nathanchen011126/APV_fullFeature_db_s2
6. 嵌入数据为：var embeddingRaw = ee.ImageCollection('GOOGLE/SATELLITE_EMBEDDING/V1/ANNUAL')
  .filterDate('2023-01-01', '2024-01-01')
  .filterBounds(roi)
  .median();。波段名为A01一直到A64.
7. 空间分辨率为30m
## 步骤1：取样与数据集划分
1. 真样本设计：从 apv_train_db 中取样，每个多边形（Polygon）取20个点。
2. 假样本设计：从 fake_nega_db_balance 中随机选取真样本总点数3倍的点。
3. 几何标准化：将真样本点转为边长60m的矩形，假样本点转为边长90m的矩形，作为基础Feature。
4. **数据集划分（Feature Level）**：
   - 在矩形Feature集合层面新增一列随机数种子（'split_rand'）。
   - 按 Feature 进行 7:3 划分：`split_rand < 0.7` 为训练集，`>= 0.7` 为测试集。
   - **注意**：必须在进行 sampleRegions 之前划分，以防止同一地块的像素同时出现在训练集和测试集中（避免空间自相关导致精度虚高）。
4. 参考代码：// 辅助函数：将 Feature(点/面) 转为指定大小的矩形 Feature
var toRect = function(feature, size, label) {
  var geom = feature.geometry();
  // 对几何中心做缓冲，确保输出规则矩形
  // 如果输入是面，先randomPoints取了点；如果输入是点，直接buffer
  return ee.Feature(geom.buffer(size/2).bounds()).set('class', label);
};

// 真样本：每个面取20个点 -> 60m矩形
var truePoints = ee.FeatureCollection.randomPoints({
  region: truePolysSource.geometry(),
  points: truePolysSource.size().multiply(PARAMS.pos_samples_per_poly),
  seed: PARAMS.seed
});
var trueRects = truePoints.map(function(f) { return toRect(f, PARAMS.pos_rect_size, 1); });

// 2.2 负样本：按1:3比例 -> 90m矩形
var trueCount = trueRects.size();
var falseCount = trueCount.multiply(PARAMS.neg_pos_ratio);
var falseRects = falsePointsSource.randomColumn().sort('random').limit(falseCount)
  .map(function(f) { return toRect(f, PARAMS.neg_rect_size, 0); });

// 合并所有样本 (用于全量训练)
var allSamples = trueRects.merge(falseRects);
print('【样本统计】真样本数:', trueRects.size(), '负样本数:', falseRects.size());

// 提取训练特征
var trainingData = featureImg.sampleRegions({
  collection: allSamples,
  properties: ['class'],
  scale: PARAMS.scale,
  tileScale: 16,
  geometries: true // 保留几何用于后续空间验证
});
## 步骤2：训练模型
1. 训练模型：使用训练集进行训练
2. 训练一个随机森林模型，树量为200，ee.Classifier.smileRandomForest。对特征影像进行分类。用概率输出。使用全部波段进行分类
3. 训练第二个随机森林模型，树量为200.对嵌入数据进行分类。也用概率输出。
4. 两个模型概率均大于0.7，则分类为真。
## 步骤3：后处理
1. 夜光掩膜：使用 VIIRS 数据，阈值设为 5，去除高亮区域。调用var viirs数据，去除掉值大于5的数据，以保证分类得到的光伏都位于农田上。参考// 1.2 制作乡村掩膜
var viirs = ee.ImageCollection("NOAA/VIIRS/DNB/MONTHLY_V1/VCMSLCFG")
  .filterDate('2023-01-01', '2023-12-31')
  .select('avg_rad')
  .median();
var rural_mask = viirs.lt(RURAL_THRESHOLD)
  .reproject({crs: baseProj, scale: 500})
  .focal_max({radius: RURAL_FOCAL_RADIUS, units: 'pixels'})
  .clip(roi);
var baseImage = featureStack.updateMask(rural_mask).clip(roi).select(bands);
2. **斑块过滤**：去除面积小于 4 个像素（约400平方米）的细碎斑块。
3. 形态学运算：使用 270m 半径进行形态学聚合（Focal Max/Closing），连接相邻的光伏地块。
4. 将分类真样本转为矢量
## 步骤4：精度验证
1. 对训练集训练好的模型进行评估3. 对测试集进行评估
2. 输出四个精度参数：准确率，kappa，生产者精度，用户精度
## 步骤5：输出结果
1. 输出矢量结果：将分类真样本转为矢量，并保存在google drive中
2. 输出精度验证结果，保存在google drive中
# 要求
1. 严格遵循GEE代码开发规范，提高计算效率
2. 只在终端中print出取样数量和精度指标，不print其他结果
3. 每次都输出可以一次跑通的全部代码。

    

